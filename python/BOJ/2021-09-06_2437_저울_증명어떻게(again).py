# 무게가 양의 정수인 N개의 저울추가 주어질 때, 
# 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 
# 최솟값을 구하는 프로그램을 작성하시오.

# 8분 투 포인터? 노 더 간단한 방법 있었음(귀납법으로 증명할 수 있음)
# https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hongjg3229&logNo=221627349685

import sys
input = sys.stdin.readline

N = int(input())
weights = list(map(int,input().split())) 
weights.sort()
num = 1 # num = (weights[i-1]까지의 누적합+1)
for i in range(N):
    if num < weights[i]:
        break
    num += weights[i]
print(num)

#       [1, 1, 2, 3, 6, 7, 30]
#       [1, 2, 4, 7,13,20, 50]
#num+1= [2, 3, 5, 8,14,21, 51]
# 가벼운 순으로 정렬
#  다시말해 지금 올리려는 추가 누적합+1보다 더 크다면, 누적합+1이 측정할 수 없는 최솟값이 된다.
# 누적합으로도 만들 수 없고, 지금 올리려는 추는 더 크니까
##### 아 여기까지는 알겠는데 그럼 앞의 누적합까지는 다 구할 수 있다는 게 와닿지 않음
# 블로그에는 '규칙에 따라 추를 하나 쌓았을 때 우리는 a0(=1)이하의 모든 수를 만들 수 있다.' 라고 설명되어있는데 잘 와닿지 않음..
###### 아 첨에 num=1로 초기화하니까
'''
우선 S-1(=0) + 1  ≥ a0인 경우 우리는 S0(=a0)을 만들 수 있고, 이 규칙을 만족하는 a0값 오직 1뿐이다. 즉, 규칙에 따라 추를 하나 쌓았을 때 우리는 a0(=1)이하의 모든 수를 만들 수 있다.  그리고 만약 위의 규칙대로 추를 쌓아서 누적합 Sn이하의 수를 모두 만들 수 있다고 가정하자. 그렇다면  Sn + 1 ≥ an+1를 만족하는 누적합 Sn+1=Sn + an+1는 Sn+1이하의 모든 양수를 만들 수 있다. 
'''
# 그리고 귀납법 자체가 n번째 원소는 '가정'하는거잖아
# 그래서 첫번째 원소가 1이 아니면 1이 바로 답임 